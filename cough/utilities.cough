dot = '.'

ObjProto = Object.prototype

compositeRegex = /\.[^\.]*\./
keypathRegex   = /\.([^\.]*)(\.?.*)$/

addComponent = (keypath, newComponent, recipient) ->
  keys  = getKeys keypath
  last  = keys.length - 1
  proxy = recipient

  # Create intermediate properties if they don't exist.
  for i in [0...last]
    key = keys[i]
    proxy[key] ?= {}
    proxy = proxy[key]

  proxy[keys[last]] = newComponent

atomicKeypath? = \keypath ->
  ! (compositeRegex.test keypath)

getComponent = (keypath, obj) ->
  if atomicKeypath? keypath
    key = keypath.slice 1
    shallowCopy obj[key]
  else
    [nextKey, nextKeypath] = processKeypath keypath
    return null unless isObject obj[nextKey]
    getComponent (nextKeypath, obj[nextKey])

getKeys = \keypath ->
  keypath.split(dot).slice(1)

identity = \val ->
  val

isArray = Array.isArray

hasType? = \type \val ->
  "[object #{type}]" == toString val

[isObject, isString] = ['Object', 'String'].map hasType?

processKeypath = \keypath ->
  keypathRegex.exec(keypath).slice(1, 3)

shallowCopy = \val ->
  switch
    when isObject val
      copy = {}
      copy[key] = prop for own key, prop of val
      copy
    when isArray val
      val.map identity
    else
      val

toString = \val ->
  ObjProto.toString.call val

transformResult = (result, fn) ->
  result = fn result

useParamListOrArray = (fn) -> (args...) ->
  if args.length && isArray args[0] then fn args[0] else fn args

compose = useParamListOrArray \fns \val ->
  fns.reduce (transformResult, val)

module.exports = {
  addComponent
  compose
  getComponent
  identity
  isArray
  isString
  shallowCopy
  useParamListOrArray
}
