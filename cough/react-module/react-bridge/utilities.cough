ObjProto = Object.prototype

applyUnsplat = (fn) -> (args...) ->
  apply fn (shallowFlatten args)

hasType? = \type \val ->
  "[object #{type}]" == toString val

[isFunction, isObject, isString] =
  ['Function', 'Object', 'String'].map hasType?

memoize = (fn, hasher) ->
  memo = {}
  hasher = identity unless isFunction hasher
  (args...) ->
    key = hasher args...
    if memo.hasOwnProperty key
      memo[key]
    else
      memo[key] = fn args...

shallowCopy = \val ->
  switch
    when isObject val
      copy = {}
      copy[key] = prop for own key, prop of val
      copy
    when isArray val
      val.map identity
    else
      val

shallowFlatten = \array ->
  nativeConcat.apply ([], array)

toString = \val ->
  ObjProto.toString.call val

module.exports = {
  applyUnsplat
  isFunction
  isObject
  isString
  memoize
  shallowCopy
}
