# This system of rescheduling should work well enough when dispatcher
# chains are synchronous; however, asynchronous chains, like those
# introduced by AJAX calls, may cause problems. The properties in a tail
# off of an asynchronous cleavage might not be updated within the same
# 'transaction' as the other nodes of the DAG, and so the atomicity
# of transactions cannot be fully guaranteed.

initiating-DAG-update? = true
DAG-updating? = false

getInitiationStatus = ->
  _initiating-DAG-update? = initiating-DAG-update?
  initiating-DAG-update? = false
  DAG-updating? = true
  _initiating-DAG-update?

reset-DAG-update-process = ->
  DAG-updating? = false
  initiating-DAG-update? = true

# -------------------------------------------------------------------------

reschedule = \thunk ->
  setTimeout (thunk, 0)

hasPostpone? = \value ->
  isCell value && (
      (innerValue = value.read ()) == postpone ||
      hasPostpone? innerValue)

# Necessary?
isPostpone? = \value ->
  value == postpone

postponed? = \value ->
  isPostpone? value || hasPostpone? value

anyPostponement? = \args ->
  args.some postponed?

# Should this deeply traverse the structure provided?
sampleProperties = \args ->
  map (\val -> if isProperty val then $sample val else val) args

cytolyse = \val ->
  if isCell val then cytolyse (val.read ()) else val

endocytate = (N, fn, managedArgs, cell) ->
  if anyPostponement? managedArgs
    cell.write postpone
    # WET: This approach at limited async recursion is used multiple times.
    reschedule (-> endocytate (N - 1, fn, managedArgs, cell)) if N > 0
  else
    cytolysedArgs = map cytolyse managedArgs
    # As of now, cells can contain other cells;
    # this possibility could be problematic.
    cell.write (fn cytolysedArgs...)
  return cell

ignoreIrrelevant = (fn) -> (args...) ->
  if args.every isRelevant then fn args... else none

###
data State = Resolved | Updating
data State s => Property s t = State s
data Potential t = Identity t | Postpone | Now t
data Capsule t = Identity t | Potential t | Property _ t

checkValue :: (a -> b) -> (Capsule a -> Potential b)
-- `remerse` relates to a comonadic action.
remerse-as-extend :: Property s a -> (Property s a -> b) -> Property s b
remerse :: Property s a -> (a -> b) -> Property s b
remerse p f = remerse-as-extend p $ f . extract
continuate :: Potential a -> (a -> b) -> b
continuate p f = case p of Identity x -> f x
                           Now x -> f x
                           Postpone -> reschedule (\_ -> continuate p f)
###

# Akin to `Bacon.combineWith`.
# TODO: Devise new name for this function.
# Perhaps a good alternative name might be 'asyncDo'.
checkValue = (fn) -> (args...) ->
  endocytate (
    10
    ignoreIrrelevant fn
    sampleProperties args
    createCell ()
  )

blockTillReady = (fn) -> (args...) ->
  blockN (10, fn, args)

try-N-times = (N) -> (fn) -> (args...) ->
  if anyPostponement? args
    reschedule (-> try-N-times (N - 1) fn (args...)) if N > 0
  else
    fn ((map cytolyse args)...)

# try10 :: (a -> b) -> (Potential a) -> b
try10 = try-N-times 10

blockN = (N, fn, args) ->
  if anyPostponement? args
    reschedule (-> blockN (N - 1, fn, args)) if N > 0
  else
    cytolysedArgs = map cytolyse args
    fn cytolysedArgs...

frpBind = (fn) -> (args...) ->
  nativeBind.apply ((checkValue fn), [null].concat args)

transbind = \transmerse \fn ->
  ; transmerse frpBind (fn) ;

# -------------------------------------------------------------------------
# Many of the functions of this section are
# also found in 'utilities2.js.cough'

getKey = \key \obj ->
  obj[key]

@prototype = getKey 'prototype'

[FuncProto, ObjProto] = [Function, Object].map @prototype

getPrototypeOf = Object.getPrototypeOf
nativeBind     = FuncProto.bind
nativeToString = ObjProto.toString

array? = \val ->
  val instanceof Array

bind = (fn) -> (args...) ->
  nativeBind.apply (fn, [null].concat args)

callOnlyOnce = (fn) ->
  fnProxy = (args...) ->
    fnProxy = noOp
    fn args...
  (args...) -> fnProxy args...

defined? = \val ->
  ? val

each = \fn \array ->
  array.forEach fn

eachProperty = \fn \obj ->
  fn val for own key, val of obj

empty? = \obj ->
  Object.keys(obj).length == 0

extend! = (obj, mixins...) ->
  for mixin in mixins
    for own key, value of mixin
      # Clobbers every value of `obj`.
      obj[key] = value
  obj

# WET.
extendProto = (prototype, mixins...) ->
  result = Object.create prototype
  for mixin in mixins
    for own key, value of mixin
      # Clobbers every value of `result`.
      result[key] = value
  result

flip = (fn) -> (args1...) -> (args2...) ->
  fn (args2...) (args1...) # Cough quirk.

function? = \val ->
  typeof val == 'function'

getArgArray = (possiblyOverbuiltArray) ->
  if array? possiblyOverbuiltArray[0]
    possiblyOverbuiltArray[0]
  else
    possiblyOverbuiltArray

hash? = \value ->
  nativeToString.call value == '[object Object]'

identity = \val ->
  val

map = \fn \value ->
  value.map fn

object? = \value ->
  # typeof value == 'object'
  # Object.prototype.toString.call value == '[object Object]'
  # value instanceof Object
  value == Object value

# -------------------------------------------------------------------------

bracket = \label ->
  '<' + label + '>'

createSingleton = \label ->
  { inspect: -> bracket label }

[active, clock, end, inactive, none, paused, postpone] =
  map createSingleton [
    'active'
    'clock'
    'end'
    'inactive'
    'none'
    'paused'
    'postpone']

noOp         = (->)
returnNoOp  = -> noOp

# Consider changing this predicate's name to `terminal?`.
isEnd = \value ->
  value == end

# TODO: Find non-negative name for this predicate.
nonterminal? = \value ->
  ! isEnd value

getType = \value ->
  if object? value then getPrototypeOf value else toString.call value

isRelevant = \value ->
  value != none

isFromType = \type \val ->
  t = getType val
  switch
    when (t == type) then true
    when not (hash? t) then false
    when (t == ObjProto) then false
    else isFromType type t

# -------------------------------------------------------------------------

createCell = \initialValue ->
  value = initialValue ?? null
  read = ->
    value
  write = \_value ->
    value = _value
  extendProto (CoreCell, { read, write })

# TODO: Refactor `isCell` to be consistent
# with other type-determining predicates.
isCell = \val -> getType val == CoreCell

# -------------------------------------------------------------------------

seed = 0
generateID = ->
  seed++

registrar = do ->
  entities = {}
  register = \entity ->
    entities[entity.id] = entity
    entity
  removeFromRegistrar = \id ->
    delete entities[id]
  transmit = (id) -> (message) -> (args...) ->
    entities[id][message] args... if entities[id]
  { register, removeFromRegistrar, transmit }

[register, removeFromRegistrar, transmit] = map (flip getKey registrar) [
  'register', 'removeFromRegistrar', 'transmit']

# -------------------------------------------------------------------------

createDispatcherType = \opts \source ->
  dispatcher = _createDispatcherType opts source
  register dispatcher
  dispatcher

# Later, refactor to use mediator more; & add a method for adding pending srcs.
# Improve memory efficiency. Many of these methods should be shared.
# Many of these internal functions can be moved outside of
# the `_createDispatcherType` function.
# (This library should be distributed across several modular files
# for greater maintainability.)
# Perhaps memory shouldn't be a determining factor.
_createDispatcherType = \opts \source ->
  { mixins, proto, transformDispatch, transformSubscribe } = parseOpts opts

  mixins              ?= {}
  proto               ?= CoreDispatcher
  source              ?= returnNoOp
  transformDispatch   ?= identity
  transformSubscribe  ?= identity

  id                 = generateID ()
  sinks              = {}
  stopSourceInflux = noOp
  terminated?        = false

  alias = id
  setAlias = \val -> alias = val # Does NOT reset alias.

  activate = callOnlyOnce ->
    # Dispatching `callOnlyOnce` on `(source dispatch)`
    # might be unnecessary, since `callOnlyOnce` has been
    # included in the function `_subscribe`.
    stopSourceInflux = callOnlyOnce (source dispatch)
  addSubscriber = \sink ->
    #sink.id = generateID () unless sink.id
    unless sink.id
      sink.id = generateID ()
    sinks[sink.id] = sink
  disconnectFrom = (sourceID, sid) ->
    subscriptionID = sid ?? id
    transmit sourceID 'unsubscribe' subscriptionID if sourceID
  _dispatch = (value, sourceID, subscriptionID) ->
    dispatch-N (10, value, sourceID, subscriptionID)
  dispatch-N = (N, value, sourceID, sid) ->
    switch
      when postponed? value
        reschedule (-> dispatch-N (N - 1, value, sourceID, sid)) if N > 0
      when terminated?
        disconnectFrom (sourceID, sid)
      else
        transact ((cytolyse value), sourceID, sid)
  distribute = \value ->
    if isEnd value
      terminate ()
    else
      _distrib = \sink ->
        sink (value, id, (sink.id || 'no-ID'))
      eachProperty _distrib sinks
  informSubscribers = ->
    # TODO: Refactor the following line.
    eachProperty (\sink -> sink end) sinks
  # Clobbered?
  _subscribe = \sink ->
    if terminated?
      # TODO: Refactor the following line.
      sink end
      noOp
    else
      addSubscriber sink
      activate ()
      # The following should be callable only once,
      # by either subscriber or dispatcher.
      callOnlyOnce -> unsubscribe sink
  terminate = ->
    stopSourceInflux ()
    terminated? = true
    informSubscribers ()
    sinks = {}
    removeFromRegistrar id
  transact = (value, sourceID, sid) ->
    updateInitiator? = getInitiationStatus ()
    try
      distribute value
      disconnectFrom (sourceID, sid) if terminated?
    finally
      reset-DAG-update-process () if updateInitiator?
  unsubscribe = \val ->
    # Validating that `val` is of ID type is possibly necessary.
    subscriberID = if function? val then val.id else val
    delete sinks[subscriberID]
    terminate () if empty? sinks

  dispatch  = transformDispatch _dispatch
  subscribe = transformSubscribe (_subscribe, unsubscribe)

  dispatch.id = id

  properties = {
    activate
    alias
    dispatch
    id
    setAlias
    subscribe
    terminate
    unsubscribe }

  # TODO: Perhaps `_createDispatcherType` can be unwrapped. Try the following:
  # register (extendProto (proto, properties, mixins))
  extendProto (proto, properties, mixins)

# -------------------------------------------------------------------------

display = \supertype \subtype ->
  -> bracket "#{supertype}: #{subtype}"

createSuperType = (display, typeLabel) ->
  inspect   : display 'Core'
  supertype : typeLabel
  type      : typeLabel

[displayCellType, displayDispatcherType, displaySignalType] =
  map display ['Cell', 'Dispatcher', 'Signal']

# WET: 'Core' + 'Cell' and 'core-cell'
CoreCell = createSuperType (displayCellType, 'core-cell')

CoreDispatcher = createSuperType (
  displayDispatcherType, 'core-dispatcher')

extendCoreDispatcher = \type ->
  inspect = displayDispatcherType type
  extendProto (CoreDispatcher, { inspect, type })

# Override clones' `insepct` methods.
[EventStream, Property] =
  map extendCoreDispatcher ['Eventstream', 'Property']

isDispatcher = isFromType CoreDispatcher

# WET.
extendCoreSignal = \type ->
  inspect = displaySignalType type
  extendProto (CoreSignal, { inspect, type })

CoreSignal = createSuperType (displaySignalType, 'core-signal')

Time = extendCoreSignal 'Time'

isEventStream = isFromType EventStream

isProperty = isFromType Property

isSignal = \value ->
  isFromType CoreSignal value || isProperty value

# -------------------------------------------------------------------------

genESOpts = (opts = {}) ->
  result = parseOpts opts
  result.proto = EventStream
  result

parseOpts = \opts ->
  if function? opts
    transformDispatch = opts
  else
    { mixins, proto, transformDispatch, transformSubscribe } = opts

  mixins             ?= {}
  proto              ?= CoreDispatcher
  transformDispatch  ?= identity
  transformSubscribe ?= identity

  { mixins, proto, transformDispatch, transformSubscribe }

parseSignalOpts = \opts ->
  if function? opts
    transformSource = opts
  else
    { mixins, proto, transformSource } = opts

  mixins          ?= {}
  proto           ?= CoreSignal
  transformSource ?= identity

  { mixins, proto, transformSource }

genPropOpts = (initialValue) -> (opts = {}) ->
  { mixins, transformDispatch, transformSubscribe } = parseOpts opts

  cachedValue  = initialValue ?? none
  ended?       = false
  proto        = Property

  read = -> cachedValue
  sample = \cell ->
    sample-N (10, cell)
  sample-N = (N, cell) ->
    if DAG-updating?
      set cell postpone
      reschedule (-> sample-N (N - 1, cell)) if N > 0
    else
      set cell (read ())
    cell
  set = \cell \val ->
    cell.write val
  write = \value -> cachedValue = value

  extend! (mixins, { read, sample, write })

  pushValueThru = \sink \value ->
    if sink.id then sink (value, sink.id, '?1') else sink (value, '?2', '?2')

  immediatelyEnd = \sink ->
    # TODO: Refactor the following line.
    pushValueThru sink end
    noOp

  _transformDispatch = (dispatch) -> (value, sourceID, sid) ->
    if isEnd value
      ended? = true
    else
      write value
    dispatch (value, sourceID, sid)

  _transformSubscribe = \subscribe \sink ->
    if isRelevant cachedValue
      pushValueThru sink cachedValue
      if ended? then immediatelyEnd sink else subscribe sink
    else
      subscribe sink

  mixins             : mixins
  proto              : proto
  transformDispatch  : (• transformDispatch _transformDispatch)
  transformSubscribe : (• transformSubscribe _transformSubscribe)

$sample = \property ->
  property.sample (createCell ())

genNonInitPropOpts = genPropOpts none

createEventStream = ; createDispatcherType genESOpts ;

createEventStreamBus = -> createEventStream () fromInternalDispatchOnly 

createNonInitProperty = ; createDispatcherType genNonInitPropOpts ;

createNonInitPropertyBus = ->
  createNonInitProperty () fromInternalDispatchOnly

createProperty = \initialValue ->
  ; createDispatcherType genPropOpts (initialValue) ;

createPropertyBus = \initialValue ->
  createProperty initialValue () fromInternalDispatchOnly

###
FayeSubscriber = { type: 'faye-subscriber' }
createFayeSubscriber = \fayeClient \source ->
  channel = null
  validNewChannel? = \value ->
    ? value && channel != value
  transformDispatch = (dispatch) -> (value, sourceID) ->
    dispatch (value, sourceID) if isEnd value
    fayeClient.unsubscribe channel if validNewChannel?
    channel = value
    fayeClient.subscribe (channel, dispatch)
  createDispatcherType { proto: FayeSubscriber, transformDispatch } source
###

# -------------------------------------------------------------------------

fromArray = \array \sink ->
  available? = true
  id         = generateID ()
  index      = 0
  length     = array.length
  unsubscribe = -> available? = false

  register { id, unsubscribe }

  while available?
    if index < length
      sink (array[index++], id, "Array-#{id}")
    else
      sink (end, id, "Array-#{id}")

  unsubscribe

fromEventTarget = \domTgt \eventName \sink ->
  sub = domTgt.addEventListener ?? (domTgt.addListener ?? domTgt.bind)
  unsub =
    domTgt.removeEventListener ?? (domTgt.removeListener ?? domTgt.unbind)
  sub.call (domTgt, eventName, sink)
  -> unsub.call (domTgt, eventName)

# TODO: Consider renaming parameters.
fromSourceFunction = (subscribe, unsubscribe) -> (sink) ->
  unsubscribe ?= returnNoOp
  subscribe sink
  -> unsubscribe sink

# WET.
fromCallback = (useAsCallback, stopUsingAsCallback) -> (sink) ->
  stopUsingAsCallback ?= returnNoOp
  # Callbacks don't have a source ID.
  _sink = \val ->
    sink val
    sink end
  useAsCallback _sink
  -> stopUsingAsCallback _sink

fromDispatcher = \dispatcher ->
  dispatcher.subscribe

fromInternalDispatchOnly = returnNoOp

fromMerger = \dispatchers \sink ->
  subscriptions = []
  dispatchers.forEach \dispatcher ->
    subscriptions.push (dispatcher.subscribe sink)
  -> subscriptions.forEach \unsubscribe -> unsubscribe ()

fromPoll = \transformSink \delayDuration \sink ->
  pollID = setInterval ((transformSink sink), delayDuration)
  -> clearInterval pollID

fromFinitePeriodicSequence = \values ->
  index = 0
  len = values.length
  fromPoll (\sink ->
    val = values[index]
    index += 1
    sink val
    sink end if index == len
  )

fromDelayedValue = \value ->
  fromFinitePeriodicSequence [value]

###
fromPromise = \promise ->
  source = \sink ->
    promise.then sink
    returnNoOp
  createPointSource source
###

# -------------------------------------------------------------------------

# What about `id`?
$dispatch = \dispatcher \value ->
  dispatcher.dispatch value

# TODO: Consider applying `checkValue` to `arg` if it's a function.
# `else (-> checkValue identity arg)`
functionize = (arg, args) ->
  switch
    when function? arg
      if array? args then bind arg args... else arg
    when keypath? arg
      \val ->
        component = getComponent (arg.slice 1) val
        if function? component then apply component args else component
    when isCell arg
      if postponed? arg
        msg = "The function 'functionize' cannot manage suspended cells."
        throw new Error msg
      else
        (-> cytolyse arg)
    else (-> arg)

blocking = blockTillReady

bindData = (sink, sourceID, sid) -> (val) ->
  sink (val, sourceID, sid)

sinkIfSinkable = (sink) -> (value, sinkable?) ->
  sink value if isEnd value || sinkable? == true

# `pred value` is checked b/c it's possible that `pred` returns
# a boolean value (or a potential boolean value) independently of `value`.
_filtering = \pred \sink \value ->
  try10 (sinkIfSinkable sink) (value, (pred value))

filtering = \pred \sink -> (value, sourceID, sid) ->
  _sink = bindData (sink, sourceID, sid)
  _filtering (checkValue pred) _sink value

_mapping = (sink) -> (originalValue, transformedValue) ->
  if isEnd originalValue
    sink originalValue
  else
    sink transformedValue

mapping = (arg, args...) ->
  fn = functionize (arg, args...)
  (sink) -> (value, sourceID, sid) ->
    _sink = bindData (sink, sourceID, sid)
    # `fn value` is eagerly determined, but this is ok in most cases.
    try10 (_mapping _sink) (value, (fn value)) 

filteringDefined = filtering defined?

filteringNonterminal = \sink -> (value, sourceID, sid) ->
  sink (value, sourceID, sid) if nonterminal? value

filteringRelevant = filtering isRelevant

delaying = \delayDuration \sink -> (value, sourceID, sid) ->
  if isEnd value
    # Should sinking of `end` be delayed too?
    sink (end, sourceID, sid)
  else
    setInterval ((-> sink (value, sourceID, sid)), delayDuration)

# Perhaps an alias should be `monitoring`?
flattening = \sink ->
  subscriptions = []
  unsub = -> subscriptions.forEach \unsubscribe -> unsubscribe ()
  (dispatcher, sourceID) ->
    if isEnd dispatcher
      unsub ()
      sink (end, sourceID)
    else
      subscriptions.push (dispatcher.subscribe sink)

monitoringFirst = \sink ->
  accepting? = true
  unsub = noOp
  \dispatcher ->
    if isEnd dispatcher
      unsub ()
      sink end
    if accepting?
      accepting? = false
      unsub = dispatcher.subscribe sink

monitoringLatest = \sink ->
  unsub = noOp
  \dispatcher ->
    if isEnd dispatcher
      unsub ()
      sink end
    else
      unsub = dispatcher.subscribe sink

permittingOnlyOneValue = \sink \value ->
  sink value
  sink end

reducing = \memo \fn \sink ->
  cachedValue = memo
  \value ->
    if nonterminal? value
      cachedValue = fn cachedValue value
    else
      sink cachedValue

staggering = \offset \sink ->
  cache    = []
  sinking? = false
  (value, sourceID, sid) ->
    cache.push [value, sourceID, sid]
    if sinking?
      args = cache.shift()
      #sink (cache.shift()...)
      sink args...
    else
      offset   = offset - 1
      sinking? = offset == 0

taking = \nbr \sink ->
  iteration = nbr
  (value, sourceID) ->
    if iteration > 0
      iteration = iteration - 1
      sink (value, sourceID)
    else
      # Should `end` automatically be sunk after last nonterminal value?
      sink (end, sourceID)

stateMachineProcessing = \initialState \fn \sink \value ->
  state = initialState
  { newState, newValue } = fn state value
  state = newState
  sink newValue

scanning = \memo \fn \sink ->
  cachedValue = memo
  \value ->
    if isEnd value
      sink value
    else
      cachedValue = fn cachedValue value
      sink cachedValue

[bfiltering, bfilteringNonterminal, bmapping] = map transbind [
  filtering, filteringNonterminal, mapping]

fmapD = \dispatcherFactory \fn \dispatcher ->
  dispatcherFactory (mapping fn) dispatcher.subscribe

$subscribe = \dispatcher \sink ->
  dispatcher.subscribe sink

_subscribe = \sink \dispatcher ->
  dispatcher.subscribe sink

# "Dispatch" as a functor.
# "Dispatch x" represents a context such that "x" shall be dispatched.
# "fmap f (Dispatch x)" ---> "Dispatch (f x)".
# "Source" as a different functor, whose context is a set of
# values to be provided.
# `remerse Dispatch f Source` ---> "Dispatch (f x), for each x of Source".

# let f be a pointed-set homomorphism from the values provided 
# by the source to the values that are to be dispatched.
# let g be a pointed-set action of the type Values → Dispatchers → ?
# g (f value) dispatcher --->

# No, a dispatcher is like but is not exactly a set acted on by a pointed set.
# It is a functor that has a member of a pointed set in its context.

merge = \tgtDispatcher \reactiveValues ->
  each (plug tgtDispatcher) reactiveValues

negating = mapping (\bool -> ! bool)

plug = \tgtDispatcher \srcDispatcher ->
  srcDispatcher.subscribe tgtDispatcher.dispatch

remerse = \dispatcherFactory \fn \source ->
  _source = if isDispatcher source then source.subscribe else source
  dispatcherFactory fn _source

transubscribe = \transmerse ->
  ; _subscribe transmerse ;

$transubscribe = \transmerse \dispatcher ->
  ; $subscribe (dispatcher) transmerse ;

onFirstAndOnlyValue = transubscribe permittingOnlyOneValue

onValue = transubscribe filteringNonterminal
$onValue = $transubscribe filteringNonterminal

# -------------------------------------------------------------------------

createSignalType = (opts = {}) -> (source) ->
  { mixins, proto, transformSource } = parseSignalOpts opts

  replaceTransform = \newTransform ->
    transformSource = newTransform

  read = -> transformSource (source ())

  extendProto (CoreSignal, { read, replaceTransform }, mixins)

# WET.
createClock = \opts ->
  errorMsg  = 'Clock is not running'
  offset     = 0
  startTime = null
  running?   = false

  currentTime = ->
    new Date ()
  pause = ->
    offset += currentTime () - startTime
    running? = false
    paused
  read = ->
    throw new Error errorMsg unless running?
    (currentTime () - startTime + offset) / 1000
  reset = ->
    running? = false
    offset = 0
    inactive
  restart = ->
    reset ()
    start ()
  start = ->
    startTime = currentTime ()
    running? = true
    active

  extendProto (clock, { pause, read, reset, restart, start })

genSignalOpts = (opts = {}) ->

genTimeOpts = (opts = {}) ->
  result = parseSignalOpts opts
  result.proto = Time
  result

createSignal = • createSignalType genSignalOpts

# WET.
createTime = • createSignalType genTimeOpts

stepper = \signal \dispatcher ->
  dispatcher.subscribe signal.replaceTransform

switcher = \signal \dispatcher ->
  read = \val -> val.read ()
  dispatcher.subscribe (• signal.replaceTransform read)

# -------------------------------------------------------------------------

fmapS = \signalFactory \fn \readable ->
  signalFactory (-> fn (readable.read ()))

liftS = \fn \readables ->
  signalFactory ->
    readables.reduce (((memo, val) -> memo = memo (val.read ())), fn)

liftS2 = \dyadicFn \readable1 \readable2 ->
  signalFactory (-> dyadicFn (readable1.read ()) (readable2.read ())) 

# -------------------------------------------------------------------------

# The first parameter of `transform` should be a dyadic function.
connect = \src \tgt \transform ->
  transform ?= identity
  newSink = transform tgt.dispatch
  # The original subscription id, if any, will be filtered out,
  # since the following function is dyadic.
  subscription = (value, sourceID) ->
    newSink (value, sourceID, subscription.id)
  subscription.id = generateID ()
  src.subscribe subscription

# -------------------------------------------------------------------------

FRP = {
  bfiltering
  bfilteringNonterminal
  blocking
  blockTillReady
  bmapping
  checkValue
  connect
  createCell
  createClock
  createDispatcherType
  createEventStream
  createEventStreamBus
  createNonInitProperty
  createNonInitPropertyBus
  createProperty
  createPropertyBus
  createSignal
  createSignalType
  createTime
  delaying
  end
  filtering
  filteringDefined
  filteringNonterminal
  filteringRelevant
  flattening
  fmapD
  fmapS
  fromArray
  fromDelayedValue
  fromFinitePeriodicSequence
  fromInternalDispatchOnly
  fromMerger
  fromPoll
  fromSourceFunction
  frpBind
  genESOpts
  genNonInitPropOpts
  genPropOpts
  getType
  isDispatcher
  isEnd
  isEventStream
  isProperty
  isRelevant
  mapping
  merge
  monitoringFirst
  monitoringLatest
  negating
  none
  onFirstAndOnlyValue
  onValue
  $onValue
  plug
  remerse
  reducing
  $sample
  scanning
  staggering
  stateMachineProcessing
  taking
  transbind
  transubscribe
}

if (? define) and (? define['amd'])
  define ([], -> FRP)
  this.FRP = FRP
else if (? module)
  module.exports = FRP
  FRP.FRP = FRP
else
  this.FRP = FRP
